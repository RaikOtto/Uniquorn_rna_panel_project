#' identify_VCF_file
#' 
#' Identifies a cancer cell lines contained in a vcf file based 
#' on the pattern (start & length) of all contained mutations/ variations.
#' 
#' \code{identify_vcf_file} parses the vcf file and predicts 
#' the identity of the sample
#' 
#' @param write_xls Create identification results additionally 
#' as xls file for easier reading
#' @param vcf_file Input vcf file. Only one sample column allowed.
#' @param output_file Path of the output file. If blank, 
#' autogenerated as name of input file plus '_uniquorn_ident.tab' suffix.
#' @param ref_gen Reference genome version. All training sets are 
#' associated with a reference genome version. Default: GRCH37
#' @param mutational_weight_inclusion_threshold Include only mutations 
#' with a weight of at least x. Range: 0.0 to 1.0. 1= unique to CL. 
#' ~0 = found in many CL samples. 
#' @param only_first_candidate Only the CL identifier with highest 
#' score is predicted to be present in the sample
#' @param minimum_matching_mutations The minimum amount of mutations that 
#' has to match between query and training sample for a positive prediction
#' @param manual_identifier_bed_file Manually enter a vector of CL 
#' name(s) whose bed files should be created, independently from 
#' them passing the detection threshold
#' @param output_bed_file If BED files for IGV visualization should be 
#' created for the Cancer Cell lines that pass the threshold
#' @param verbose Print additional information
#' @param p_value Required p-value for identification
#' @param q_value Required q-value for identification
#' @param confidence_score Threshold above which a positive prediction occurs
#' default 10.0
#' @import DBI WriteXLS RSQLite stats
#' @usage 
#' identify_vcf_file( 
#' vcf_file,
#' output_file = "",
#' ref_gen = "GRCH37",
#' minimum_matching_mutations = 0,
#' mutational_weight_inclusion_threshold = 0.5,
#' only_first_candidate = FALSE,
#' write_xls = FALSE,
#' output_bed_file = FALSE,
#' manual_identifier_bed_file = "",
#' verbose = FALSE,
#' p_value = .05,
#' q_value = .05,
#' confidence_score = 10.0)
#' @examples 
#' HT29_vcf_file = system.file("extdata/HT29.vcf.gz", package="Uniquorn");
#' 
#' identification = identify_vcf_file( HT29_vcf_file )
#' @return R table with a statistic of the identification result
#' @export
identify_vcf_file = function(
    vcf_file,
    output_file = "",
    ref_gen = "GRCH37",
    minimum_matching_mutations = 0,
    mutational_weight_inclusion_threshold = 0.5,
    only_first_candidate = FALSE,
    write_xls = FALSE,
    output_bed_file = FALSE,
    manual_identifier_bed_file = "",
    verbose = FALSE,
    p_value = .05,
    q_value = .05,
    confidence_score = 10.0
    ){
  
    path_names = init_and_load_identification( 
        verbose = verbose, vcf_file = vcf_file, 
        ref_gen = ref_gen, output_file = output_file
    )
    vcf_file_name   = path_names$vcf_file_name
    output_file     = path_names$output_file
    output_file_xls = path_names$output_file_xls
    vcf_fingerprint = path_names$vcf_fingerprint

    sim_list       = initiate_db_and_load_data( 
        ref_gen = ref_gen, 
        request_table = "sim_list" 
    )
    sim_list_stats = initiate_db_and_load_data(
        ref_gen = ref_gen, 
        request_table = "sim_list_stats"
    )
    
    if ( ( 
        sum( 
            grepl( 
                "_COSMIC", sim_list_stats$CL ) ) + sum( grepl( "_CCLE", sim_list_stats$CL ) 
            ) 
        ) == 0 
    )
        
      if( verbose )
          warning("CCLE & CoSMIC CLP cancer cell line fingerprint NOT 
              found, defaulting to 60 CellMiner cancer cell lines! 
              It is strongly advised to add ~1900 CCLE & CoSMIC CLs, see readme."
        )

    sim_list = sim_list[ sim_list$Ref_Gen == ref_gen  ,]
    sim_list_stats = sim_list_stats[ sim_list_stats$Ref_Gen == ref_gen  ,]
    
    if (verbose)
        print( base::paste0( c("Found ", base::as.character( 
            base::length( unique(sim_list$CL) ) ), " many CLs for reference genome ", 
            ref_gen ), collapse = "" ) )
    
    if (verbose)
        print("Finished reading database, identifying CL")
    
    filtered_res = filter_for_weights( 
        sim_list = sim_list,
        sim_list_stats = sim_list_stats,
        ref_gen = ref_gen,
        mutational_weight_inclusion_threshold = mutational_weight_inclusion_threshold,
        verbose = verbose
    )
    sim_list = filtered_res$sim_list
    sim_list_stats = filtered_res$sim_list_stats
    
    contained_cls_original = sim_list_stats$CL
    
    dif = length(contained_cls_original) - 
        length (sim_list_stats$CL)
    
    dif_cls = contained_cls_original[
        which(!(contained_cls_original %in% sim_list_stats$CL))
    ]
    
    if ( ( dif != 0 ) & verbose )
        
        warning(paste0(c(
            as.character(dif),
            " CLs have no mutations for the chosen weight 
            and cannot be identified: ",
            paste0(c(dif_cls), collapse = ", ")
            , " Probably they are too closely simlar to other training CLs"),
            collapse=""
    ))
    
    found_mut_mapping = which(
        sim_list$Fingerprint %in% as.character(
            unlist(
                vcf_fingerprint
            )
        )
    ) # mapping
    
    list_of_cls = unique( sim_list$CL )
    
    panels = unique( sapply( list_of_cls, FUN = function( cl_name ){
        return(
            paste0( "_",
                    utils::tail( 
                        unlist( stringr::str_split( cl_name, pattern = "_") ),
                        1 ) 
            )
        )
    } ) )
    
    res_table = calculate_similarity_results(
        sim_list = sim_list,
        sim_list_stats = sim_list_stats,
        found_mut_mapping = found_mut_mapping,
        minimum_matching_mutations = minimum_matching_mutations,
        p_value = p_value,
        q_value = q_value,
        confidence_score = confidence_score,
        vcf_fingerprint,
        panels = panels,
        list_of_cls = list_of_cls
    )
    
    res_table = add_missing_cls( res_table, dif_cls )
    
    ### correction background
    
    res_table_statistic = res_table[ 
        res_table$Found_muts != res_table$Count_mutations
    , ]
    # this is done to avoid distortion of the statistic
    # due to benchmarking the DB with its own fingerprints
    
    nr_matching_variants = as.double( res_table_statistic$Found_muts[ 
        as.double( res_table_statistic$Found_muts ) > 0 
    ] )
    
    if ( length(nr_matching_variants) == 0 ){
        
        penalty = 0
        penalty_mutations = 0
        
    } else{ 

        penalty = integrate(
            f = pbeta,
            0,
            1,
            max( nr_matching_variants ) / mean( nr_matching_variants ),
            max( nr_matching_variants ) / mean( nr_matching_variants ),
            stop.on.error = FALSE
        )$value
        
        penalty_mutations = 
            ceiling(
                mean( nr_matching_variants ) + 
                    ( max( nr_matching_variants ) * penalty ) / 
                    ( 1 - penalty )
            )
    }
    
    
    if ( ( minimum_matching_mutations == 0 ) & ( penalty > 0.01) ){
        
        res_table$Conf_score_sig = as.character( 
            ( as.integer( res_table$Found_muts ) > 
                  as.integer( penalty_mutations ) ) &&
            as.logical( res_table$Conf_score_sig )
        )
        
        message( paste0( collapse = "", c( 
            "Correcting the background due to traces of random, scale-freeness amounts of matches, 
            requiring at least ", 
            as.character( penalty_mutations ), " variants to match." ) )
        )
    }
    
    res_table = rbind( res_table_statistic , res_table) 
   
    if (only_first_candidate)
        
      res_table$Conf_score_sig[ seq(2, length(res_table$Conf_score_sig)) ] = FALSE
    
    if ( verbose )
        
      print( paste0( "Candidate(s): ", paste0( ( unique( 
            as.character( res_table$CL )[ res_table$Conf_score_sig == TRUE  ]) ), 
            collapse = "," ) )  )
    
    if( verbose )
        
      print( paste0("Storing information in table: ",output_file ) )
    
    utils::write.table( 
        res_table,
        output_file,
        sep ="\t",
        row.names = FALSE,
        quote = FALSE
    )
    
    if (output_bed_file & ( sum( as.logical(res_table$Q_value_sig) ) > 0 ))
         create_bed_file( 
             sim_list, 
             vcf_fingerprint, 
             res_table, 
             output_file, 
             ref_gen, 
             manual_identifier_bed_file
        )
    
    if ( !verbose )
        res_table = res_table[ ,
            !( colnames( res_table ) %in% c(
                "P_values",
                "Q_values",
                "P_value_sig",
                "Q_value_sig"
                )
            )
        ]

    
    if ( write_xls )

        WriteXLS::WriteXLS( 
            x = res_table,
            path.expand(
                output_file_xls
            ),
            row.names = FALSE
        )
    
    return( res_table )
}

